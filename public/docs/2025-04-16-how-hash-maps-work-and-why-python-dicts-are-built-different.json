{
  "id": "how-hash-maps-work-and-why-python-dicts-are-built-different",
  "title": "How Hash Maps Work (and Why Python Dicts Are Built Different)",
  "description": "LLM-generated CS blog lesson on How Hash Maps Work (and Why Python Dicts Are Built Different).",
  "sidebar_position": 1,
  "tags": [
    "hash",
    "python",
    "dicts"
  ],
  "date": "2025-04-16",
  "content": "# How Hash Maps Work (and Why Python Dicts Are Built Different)\n================================================================================\n\n## Introduction to Hash Maps\nHash maps, also known as hash tables, are one of the most fundamental data structures in computer science. They're like the **Swiss Army knives** of data structures \u2013 versatile, efficient, and ridiculously useful. But have you ever wondered how they work under the hood? In this post, we'll dive into the fascinating world of hash maps and explore why Python's dictionaries are built a little differently.\n\n### What's a Hash Map, Anyway?\nA hash map is a data structure that stores **key-value pairs** in a way that allows for fast lookups, insertions, and deletions. It's like a phonebook where you can look up a person's phone number by their name. The \"hash\" part refers to the fact that we use a **hash function** to map the key (e.g., the person's name) to a specific location in memory where the corresponding value (e.g., the phone number) is stored.\n\n## How Hash Maps Work\nHere's a simplified overview of the hash map workflow:\n\n1. **Key hashing**: When you insert a key-value pair into the hash map, the key is passed through a hash function that generates a **hash code**. This hash code is like a unique fingerprint for the key.\n2. **Index calculation**: The hash code is then used to calculate an **index** into an array of **buckets**. Each bucket can hold multiple key-value pairs.\n3. **Collision resolution**: If two keys hash to the same index (this is called a **collision**), the hash map uses a technique like **chaining** or **open addressing** to resolve the conflict.\n\n### Example Code: A Simple Hash Map in Python\n```python\nclass HashMap:\n    def __init__(self):\n        self.size = 10\n        self.buckets = [[] for _ in range(self.size)]\n\n    def _hash(self, key):\n        return hash(key) % self.size\n\n    def put(self, key, value):\n        index = self._hash(key)\n        bucket = self.buckets[index]\n        for i, (k, v) in enumerate(bucket):\n            if k == key:\n                bucket[i] = (key, value)\n                break\n        else:\n            bucket.append((key, value))\n\n    def get(self, key):\n        index = self._hash(key)\n        bucket = self.buckets[index]\n        for k, v in bucket:\n            if k == key:\n                return v\n        return None\n\n# Create a hash map and insert some key-value pairs\nhash_map = HashMap()\nhash_map.put(\"John\", \"123-456-7890\")\nhash_map.put(\"Jane\", \"987-654-3210\")\n\n# Retrieve a value by its key\nprint(hash_map.get(\"John\"))  # Output: 123-456-7890\n```\n\n## Why Python Dictionaries Are Built Different\nPython's dictionaries (which are implemented as hash maps) have some unique features that set them apart from other hash map implementations. For one, Python dictionaries use a technique called **open addressing** to resolve collisions, whereas many other hash maps use chaining.\n\n### Open Addressing vs. Chaining\n**Open addressing** works by probing other indices in the array until an empty slot is found. This can lead to **clustering**, where multiple collisions occur in the same region of the array. To mitigate this, Python dictionaries use a technique called **perturbative probing**, which helps to distribute the collisions more evenly.\n\n**Chaining**, on the other hand, works by storing colliding key-value pairs in a linked list at the same index. This can lead to slower lookup times, especially for large datasets.\n\n### Python's Dictionary Implementation\nPython's dictionary implementation is highly optimized and uses a number of clever techniques to improve performance. For example, Python dictionaries use a **load factor** to determine when to resize the underlying array. When the load factor exceeds a certain threshold, the dictionary is resized to maintain a consistent level of performance.\n\n### Example Code: Python's Dictionary Implementation\n```python\nimport sys\n\n# Create a Python dictionary\nd = {\"John\": \"123-456-7890\", \"Jane\": \"987-654-3210\"}\n\n# Print the dictionary's size and load factor\nprint(sys.getsizeof(d))  # Output: 240 (approximate size in bytes)\nprint(len(d))  # Output: 2 (number of key-value pairs)\n```\n\n## Conclusion\nHash maps are a fundamental data structure in computer science, and Python's dictionaries are a great example of how they can be implemented efficiently. By understanding how hash maps work and how Python's dictionaries are built differently, you can write more efficient and effective code. So next time you use a Python dictionary, remember that there's a lot of clever engineering going on under the hood!\n\n**Additional Resources**\n\n* [Python Dictionary Implementation](https://github.com/python/cpython/blob/main/Objects/dictobject.c)\n* [Hash Map Tutorial](https://www.geeksforgeeks.org/hash-table-implementation-in-python/)\n* [Open Addressing vs. Chaining](https://en.wikipedia.org/wiki/Hash_table#Open_addressing_vs._chaining)"
}