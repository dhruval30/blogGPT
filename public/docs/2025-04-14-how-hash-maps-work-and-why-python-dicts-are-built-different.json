{
  "id": "how-hash-maps-work-and-why-python-dicts-are-built-different",
  "title": "How Hash Maps Work (and Why Python Dicts Are Built Different)",
  "description": "LLM-generated CS blog lesson on How Hash Maps Work (and Why Python Dicts Are Built Different).",
  "sidebar_position": 1,
  "tags": [
    "python",
    "hash",
    "dicts"
  ],
  "date": "2025-04-14",
  "content": "# How Hash Maps Work (and Why Python Dicts Are Built Different)\n===========================================================\n\nHey fellow devs, have you ever wondered how those magical `dict`s in Python work their magic? You know, the ones that let you store and retrieve data in constant time, like a superpower? Well, today we're going to lift the lid on **hash maps**, the data structure behind the scenes, and explore why Python's `dict`s are built a little differently.\n\n## What's a Hash Map, Anyway?\n---------------------------\n\nImagine a librarian who uses a **super-smart cataloging system** to store and retrieve books in a massive library. When you give the librarian a book title, they use a special formula (the **hash function**) to determine the exact shelf where the book should be stored. This way, when you ask for a book, the librarian can quickly find it by applying the same formula and heading straight to the correct shelf.\n\nIn computer science, this librarian is like a **hash map**, a data structure that stores key-value pairs in a way that allows for lightning-fast lookups, insertions, and deletions. The **hash function** is the magic formula that maps each key to a specific **index** in an array, where the corresponding value is stored.\n\n### A Simple Hash Map Example\n-----------------------------\n\nHere's a simple example of a hash map implemented in Python:\n```python\nclass SimpleHashMap:\n    def __init__(self):\n        self.size = 10\n        self.table = [[] for _ in range(self.size)]\n\n    def _hash(self, key):\n        return hash(key) % self.size\n\n    def put(self, key, value):\n        index = self._hash(key)\n        for pair in self.table[index]:\n            if pair[0] == key:\n                pair[1] = value\n                return\n        self.table[index].append([key, value])\n\n    def get(self, key):\n        index = self._hash(key)\n        for pair in self.table[index]:\n            if pair[0] == key:\n                return pair[1]\n        return None\n```\nIn this example, the `_hash` method uses the built-in `hash` function to generate a hash code for the key, and then applies the modulo operator to map it to an index in the `table` array.\n\n## The Problem with Simple Hash Maps\n-----------------------------------\n\nSo, why doesn't Python's `dict` use a simple hash map like the one above? Well, there are a few issues:\n\n* **Collisions**: When two different keys hash to the same index, we get a collision. In our simple example, we handle collisions by storing multiple key-value pairs in the same index, but this leads to slower lookup times.\n* **Resizing**: When the hash map grows or shrinks, we need to rehash all the existing key-value pairs to maintain the correct indexing.\n\n## Python's Dict: A More Complex Hash Map\n------------------------------------------\n\nPython's `dict` uses a more complex hash map implementation that addresses these issues. Here are some key features:\n\n* **Open addressing**: Python's `dict` uses open addressing, which means that when a collision occurs, it probes other indices in the table to find an empty slot.\n* **Resizing**: Python's `dict` resizes the table dynamically, doubling its size when it reaches a certain load factor.\n* **Custom hash functions**: Python's `dict` uses custom hash functions for different types of keys, such as strings, integers, and tuples.\n\n### A Peek into Python's Dict Implementation\n-----------------------------------------\n\nHere's a simplified example of how Python's `dict` implementation might look:\n```python\nclass PythonDict:\n    def __init__(self):\n        self.size = 8\n        self.table = [None] * self.size\n        self.load_factor = 0.66\n\n    def _hash(self, key):\n        # Custom hash function for different types of keys\n        if isinstance(key, str):\n            return self._string_hash(key)\n        elif isinstance(key, int):\n            return self._int_hash(key)\n        else:\n            raise TypeError(\"Unsupported key type\")\n\n    def _string_hash(self, key):\n        # Simple string hash function\n        return sum(ord(c) for c in key) % self.size\n\n    def _int_hash(self, key):\n        # Simple int hash function\n        return key % self.size\n\n    def put(self, key, value):\n        index = self._hash(key)\n        if self.table[index] is None:\n            self.table[index] = [(key, value)]\n        else:\n            # Handle collisions using open addressing\n            for i in range(self.size):\n                index = (index + i) % self.size\n                if self.table[index] is None:\n                    self.table[index] = [(key, value)]\n                    return\n                elif self.table[index][0][0] == key:\n                    self.table[index][0] = (key, value)\n                    return\n            # Resize the table if it's too full\n            self._resize()\n\n    def _resize(self):\n        new_size = self.size * 2\n        new_table = [None] * new_size\n        for pair in self.table:\n            if pair is not None:\n                index = self._hash(pair[0][0]) % new_size\n                if new_table[index] is None:\n                    new_table[index] = [pair[0]]\n                else:\n                    new_table[index].append(pair[0])\n        self.size = new_size\n        self.table = new_table\n```\nThis is a highly simplified example, but it should give you an idea of the extra complexity that goes into Python's `dict` implementation.\n\n## Conclusion\n----------\n\nHash maps are an incredibly powerful data structure that underlies many of the data structures we use in programming. By understanding how they work and the trade-offs involved, we can write more efficient and effective code. Python's `dict` implementation is a great example of how a well-designed hash map can make a huge difference in performance and usability.\n\nSo, next time you use a `dict` in Python, remember the clever librarian and the complex hash map implementation that's working behind the scenes to make your code faster and more efficient!"
}